generator kysely {
  provider = "prisma-kysely"
}

generator client {
  provider = "prisma-client-js"
}

generator json {
  provider = "prisma-json-types-generator"
}

generator zod {
  provider             = "zod-prisma-types"
  createInputTypes     = false
  writeBarrelFiles     = false
  useMultipleFiles     = true
  useDefaultValidators = false
}

datasource db {
  provider  = "postgresql"
  url       = env("NEXT_PRIVATE_DATABASE_URL")
  directUrl = env("NEXT_PRIVATE_DIRECT_DATABASE_URL")
}

// Todo: (RR7) Remove after RR7 migration.
enum IdentityProvider {
  DOCUMENSO
  GOOGLE
  OIDC
}

enum Role {
  ADMIN
  USER
}

enum TypeSongAlbum {
  SONG
  ALBUM
}

enum StatusSongAlbum {
  DELETED
  RELEASED
  PENDING
  DRAFT
}

model User {
  id               Int                @id @default(autoincrement())
  name             String?
  customerId       String?            @unique
  email            String             @unique
  emailVerified    DateTime?
  password         String? // Todo: (RR7) Remove after RR7 migration.
  source           String?
  signature        String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @default(now()) @updatedAt
  lastSignedIn     DateTime           @default(now())
  roles            Role[]             @default([USER])
  identityProvider IdentityProvider   @default(DOCUMENSO) // Todo: (RR7) Remove after RR7 migration.
  avatarImageId    String?
  disabled         Boolean            @default(false)
  releases         Releases[]
  tuStreams        tuStreams[]
  tuStreamsArtists tuStreamsArtists[]

  territories                         Territories[]
  releasesArtists                     releasesArtists[]
  artists                             Artist[]
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]
  distributionStatementTerritories    DistributionStatementTerritories[]
  isrcArtists                         IsrcArtists[]
  distributionStatement               DistributionStatement[]
  accounts                            Account[]
  sessions                            Session[]
  musicPlatforms                      MusicPlatforms[]
  documents                           Document[]
  folders                             Folder[]
  contracts                           Contract[]
  subscriptions                       Subscription[]
  passwordResetTokens                 PasswordResetToken[]
  ownedTeams                          Team[]
  ownedPendingTeams                   TeamPending[]
  teamMembers                         TeamMember[]
  twoFactorSecret                     String?
  twoFactorEnabled                    Boolean                               @default(false)
  twoFactorBackupCodes                String?
  url                                 String?                               @unique
  lpm                                 lpm[]
  iscrSongs                           IsrcSongs[]
  profile                             UserProfile?
  verificationTokens                  VerificationToken[]
  apiTokens                           ApiToken[]
  templates                           Template[]
  taskAssignees                       TaskAssignee[]
  taskComments                        TaskComment[]
  taskAttachments                     TaskAttachment[]
  taskSubtasks                        Task[]
  securityAuditLogs                   UserSecurityAuditLog[]
  webhooks                            Webhook[]
  siteSettings                        SiteSettings[]
  passkeys                            Passkey[]
  Chat                                Chat[]
  lpmProductDisplayArtists            lpmProductDisplayArtists[]
  avatarImage                         AvatarImage?                          @relation(fields: [avatarImageId], references: [id], onDelete: SetNull)
  ChatDocuments                       ChatDocument[]
  Suggestion                          Suggestion[]

  @@index([email])
}

model UserProfile {
  id      String  @id @default(cuid())
  enabled Boolean @default(false)
  userId  Int     @unique
  bio     String?

  User User? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model lpmProductDisplayArtists {
  id         Int      @id @default(autoincrement())
  artistId   Int
  artistName String
  lpm        lpm[]
  createdAt  DateTime @default(now())
  userId     Int?
  teamId     Int?

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team?  @relation(fields: [teamId], references: [id], onDelete: SetNull)
  artist Artist @relation(fields: [artistId], references: [id])
}

model releasesArtists {
  id         Int        @id @default(autoincrement())
  artistId   Int
  artistName String
  Releases   Releases[]
  createdAt  DateTime   @default(now())
  userId     Int?
  teamId     Int?

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team?  @relation(fields: [teamId], references: [id], onDelete: SetNull)
  artist Artist @relation(fields: [artistId], references: [id])
}

model Artist {
  id                Int                        @id @default(autoincrement())
  name              String                     @unique
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @default(now()) @updatedAt
  roles             Role[]                     @default([USER])
  avatarImageId     String?
  disabled          Boolean?                   @default(false)
  event             Event[]
  url               String?                    @unique
  ArtistProfile     ArtistProfile?
  isrcArtists       IsrcArtists[]
  releasesArtists   releasesArtists[]
  lpmProductArtists lpmProductDisplayArtists[]
  songs             Songs[]
  isrcSongs         IsrcSongs[] // Added for many-to-many relation with IsrcSongs
  lpm               lpm[]
  userId            Int?
  teamId            Int?
  tuStreams         tuStreams[]
  tuStreamsArtists  tuStreamsArtists[]

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  team Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)
}

model ArtistProfile {
  id       String  @id @default(cuid())
  enabled  Boolean @default(false)
  artistId Int     @unique
  bio      String?

  Artist Artist? @relation(fields: [artistId], references: [id], onDelete: Cascade)
}

model Songs {
  id                Int               @id @default(autoincrement())
  name              String?
  author            String?
  teamId            Int?
  publisherMexico   String?
  publisherUSA      String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @default(now()) @updatedAt
  disabled          Boolean           @default(false)
  artists           Artist[]
  url               String?           @unique
  type              TypeSongAlbum[]
  status            StatusSongAlbum[]
  uniqueIdentifier  String?           @unique @default(cuid())
  royaltyPercentage String?
  team              Team?             @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model lpm {
  id                                  Int       @id @default(autoincrement())
  productId                           String?   @map("productId")
  productType                         String?   @map("Product Type")
  productTitle                        String?   @map("Product Title")
  productVersion                      String?   @map("Product Version")
  productDisplayArtist                String?   @map("Product Display Artist")
  parentLabel                         String?   @map("Parent Label")
  label                               String?   @map("label")
  originalReleaseDate                 DateTime? @map("Original Release Date")
  releaseDate                         DateTime? @map("Release Date")
  upc                                 String?   @map("UPC")
  catalog                             String?   @map("Catalog ")
  productPriceTier                    String?   @map("Product Price Tier")
  productGenre                        String?   @map("Product Genre")
  submissionStatus                    String?   @map("Submission Status")
  productCLine                        String?   @map("Product C Line")
  productPLine                        String?   @map("Product P Line")
  preOrderDate                        DateTime? @map("PreOrder Date")
  exclusives                          String?   @map("Exclusives")
  explicitLyrics                      String?   @map("ExplicitLyrics")
  productPlayLink                     String?   @map("Product Play Link")
  linerNotes                          String?   @map("Liner Notes")
  primaryMetadataLanguage             String?   @map("Primary Metadata Language")
  compilation                         String?   @map("Compilation")
  pdfBooklet                          String?   @map("PDF Booklet")
  timedReleaseDate                    DateTime? @map("Timed Release Date")
  timedReleaseMusicServices           DateTime? @map("Timed Release Music Services")
  lastProcessDate                     DateTime? @map("Last Process Date")
  importDate                          DateTime? @map("Import Date")
  createdBy                           String?   @map("Created By")
  lastModified                        DateTime? @map("Last Modified")
  submittedAt                         DateTime? @map("Submitted At")
  submittedBy                         String?   @map("Submitted By")
  vevoChannel                         String?   @map("Vevo Channel")
  trackType                           String?   @map("TrackType")
  trackId                             String?   @map("Track Id")
  trackVolume                         Boolean?  @map("Track Volume")
  trackNumber                         String?   @map("Track Number")
  trackName                           String?   @map("Track Name")
  trackVersion                        String?   @map("Track Version")
  trackDisplayArtist                  String?   @map("Track Display Artist")
  isrc                                String?   @map("Isrc")
  trackPriceTier                      String?   @map("Track Price Tier")
  trackGenre                          String?   @map("Track Genre")
  audioLanguage                       String?   @map("Audio Language")
  trackCLine                          String?   @map("Track C Line")
  trackPLine                          String?   @map("Track P Line")
  writersComposers                    String?   @map("WritersComposers")
  publishersCollectionSocieties       String?   @map("PublishersCollection Societies")
  withholdMechanicals                 String?   @map("Withhold Mechanicals")
  preOrderType                        String?   @map("PreOrder Type")
  instantGratificationDate            DateTime? @map("Instant Gratification Date")
  duration                            String?   @map("Duration")
  sampleStartTime                     String?   @map("Sample Start Time")
  explicitLyricsTrack                 String?   @map("Explicit Lyrics")
  albumOnly                           String?   @map("Album Only")
  lyrics                              String?   @map("Lyrics")
  additionalContributorsPerforming    String?   @map("AdditionalContributorsPerforming")
  additionalContributorsNonPerforming String?   @map("AdditionalContributorsNonPerforming")
  producers                           String?   @map("Producers")
  continuousMix                       String?   @map("Continuous Mix")
  continuouslyMixedIndividualSong     String?   @map("Continuously Mixed Individual Song")
  trackPlayLink                       String?   @map("Track Play Link")

  userId     Int?
  teamId     Int?
  artists    Artist[]
  lpmArtists lpmProductDisplayArtists[]

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  team Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)
}

enum ContractStatus {
  VIGENTE
  FINALIZADO
  NO_ESPECIFICADO
}

enum ExpansionPossibility {
  SI
  NO
  NO_ESPECIFICADO
}

enum RetentionAndCollectionPeriod {
  SI
  NO
  NO_ESPECIFICADO
}

enum ContractType {
  ARRENDAMIENTOS
  ALQUILERES
  VEHICULOS
  SERVICIOS
  ARTISTAS
}

model Contract {
  id       Int     @id @default(autoincrement())
  title    String  @db.Text
  fileName String? @db.Text

  artists                     String?                       @db.Text
  startDate                   DateTime?
  endDate                     DateTime?
  isPossibleToExpand          ExpansionPossibility          @default(NO_ESPECIFICADO)
  possibleExtensionTime       String?
  status                      ContractStatus?               @default(NO_ESPECIFICADO)
  collectionPeriod            RetentionAndCollectionPeriod?
  retentionPeriod             RetentionAndCollectionPeriod?
  retentionPeriodDescription  String?
  retentionPeriodDuration     String?
  collectionPeriodDescription String?
  collectionPeriodDuration    String?
  contractType                ContractType?
  documentId                  Int
  createdAt                   DateTime                      @default(now())
  updatedAt                   DateTime                      @updatedAt
  summary                     String?                       @db.Text
  userId                      Int?
  teamId                      Int?
  folder                      Folder?                       @relation(fields: [folderId], references: [id], onDelete: Cascade)
  folderId                    String?
  user                        User?                         @relation(fields: [userId], references: [id], onDelete: SetNull)
  team                        Team?                         @relation(fields: [teamId], references: [id], onDelete: SetNull)

  @@index([folderId])
  @@map("Contracts")
}

model Territories {
  id                               Int                                @id @default(autoincrement())
  name                             String?                            @unique
  createdAt                        DateTime                           @default(now())
  updatedAt                        DateTime                           @default(now()) @updatedAt
  avatarImageId                    String?
  disabled                         Boolean?                           @default(false)
  userId                           Int?
  teamId                           Int?
  distributionStatementTerritories DistributionStatementTerritories[]
  user                             User?                              @relation(fields: [userId], references: [id], onDelete: SetNull)
  team                             Team?                              @relation(fields: [teamId], references: [id], onDelete: SetNull)
}

model DistributionStatementTerritories {
  id                    Int                     @id @default(autoincrement())
  territoryId           Int
  name                  String
  createdAt             DateTime                @default(now())
  userId                Int?
  teamId                Int?
  distributionStatement DistributionStatement[]

  user      User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  team      Team?       @relation(fields: [teamId], references: [id], onDelete: SetNull)
  territory Territories @relation(fields: [territoryId], references: [id])
}

model DistributionStatementMusicPlatforms {
  id                    Int                     @id @default(autoincrement())
  platformId            Int
  name                  String
  createdAt             DateTime                @default(now())
  userId                Int?
  teamId                Int?
  distributionStatement DistributionStatement[]

  user     User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  team     Team?          @relation(fields: [teamId], references: [id], onDelete: SetNull)
  platform MusicPlatforms @relation(fields: [platformId], references: [id])
}

model MusicPlatforms {
  id                                  Int                                   @id @default(autoincrement())
  name                                String?                               @unique
  createdAt                           DateTime                              @default(now())
  updatedAt                           DateTime                              @default(now()) @updatedAt
  avatarImageId                       String?
  disabled                            Boolean?                              @default(false)
  url                                 String?                               @unique
  userId                              Int?
  teamId                              Int?
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  team Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)
}

model DistributionStatement {
  id                                  Int                                   @id @default(autoincrement())
  marketingOwner                      String?                               @map("Marketing Owner")
  nombreDistribucion                  String?                               @map("Nombre Distribucion")
  proyecto                            String?                               @map("Projecto")
  numeroDeCatalogo                    String?                               @map("Numero de Catalogo")
  upc                                 String?                               @map("UPC")
  localProductNumber                  String?                               @map("Local Product Number")
  isrc                                String?                               @map("ISRC")
  tituloCatalogo                      String?                               @map("Titulo catalogo")
  mesReportado                        Int?                                  @map("Mes Reportado")
  territorio                          String?                               @map("Territorio")
  codigoDelTerritorio                 String?                               @map("Codigo del Territorio")
  nombreDelTerritorio                 String?                               @map("Nombre del Territorio")
  tipoDePrecio                        String?                               @map("Tipo de Precio")
  tipoDeIngreso                       String?                               @map("Tipo de Ingreso")
  venta                               Float?                                @map("Venta")
  rtl                                 Float?                                @map("RTL")
  ppd                                 Float?                                @map("PPD")
  rbp                                 Float?                                @map("RBP")
  tipoDeCambio                        Float?                                @map("Tipo de Cambio:")
  valorRecibido                       Float?                                @map("Valor Recibido")
  regaliasArtisticas                  Float?                                @map("Regalias Artisticas")
  costoDistribucion                   Float?                                @map("Costo Distribucion")
  copyright                           Float?                                @map("Copyright")
  cuotaAdministracion                 Float?                                @map("Cuota Administracion")
  costoCarga                          Float?                                @map("Costo Carga")
  otrosCostos                         Float?                                @map("Otros Costos")
  ingresosRecibidos                   Float?                                @map("Ingresos Recibidos")
  createdAt                           DateTime                              @default(now())
  updatedAt                           DateTime                              @default(now()) @updatedAt
  userId                              Int?
  teamId                              Int?
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]
  distributionStatementTerritories    DistributionStatementTerritories[]

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  team Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([teamId])
}

model Releases {
  id              Int               @id @default(autoincrement())
  date            String?
  artist          String?
  lanzamiento     String?
  typeOfRelease   TypeOfRelease?
  release         Release?
  uploaded        String?
  streamingLink   String?
  assets          Boolean?
  canvas          Boolean?
  cover           Boolean?
  audioWAV        Boolean?
  video           Boolean?
  banners         Boolean?
  pitch           Boolean?
  EPKUpdates      Boolean?
  WebSiteUpdates  Boolean?
  Biography       Boolean?
  userId          Int?
  teamId          Int?
  releasesArtists releasesArtists[]
  user            User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  team            Team?             @relation(fields: [teamId], references: [id], onDelete: SetNull)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @default(now())
}

model IsrcArtists {
  id         Int         @id @default(autoincrement())
  artistId   Int
  artistName String
  isrcSongs  IsrcSongs[]
  createdAt  DateTime    @default(now())
  userId     Int?
  teamId     Int?

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team?  @relation(fields: [teamId], references: [id], onDelete: SetNull)
  artist Artist @relation(fields: [artistId], references: [id])
}

model IsrcSongs {
  id        Int       @id @default(autoincrement())
  date      DateTime?
  isrc      String?
  artist    String?
  duration  String?
  trackName String?
  title     String?
  license   String?
  userId    Int?
  teamId    Int?

  isrcArtists IsrcArtists[]

  createdAt DateTime @default(now())

  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  team     Team?    @relation(fields: [teamId], references: [id], onDelete: SetNull)
  memebers Artist[]
}

model tuStreamsArtists {
  id         Int         @id @default(autoincrement())
  artistId   Int
  artistName String
  tuStreams  tuStreams[]
  createdAt  DateTime    @default(now())
  userId     Int?
  teamId     Int?

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team?  @relation(fields: [teamId], references: [id], onDelete: SetNull)
  artist Artist @relation(fields: [artistId], references: [id])
}

enum TypeOfTuStreams {
  Sencillo
  Album
  Single
  EP
}

model tuStreams {
  id     Int              @id @default(autoincrement())
  title  String?
  UPC    String?
  artist String?
  type   TypeOfTuStreams?
  total  Float?
  date   DateTime?

  userId Int?
  teamId Int?

  tuStreamsArtists tuStreamsArtists[]
  createdAt        DateTime           @default(now())
  user             User?              @relation(fields: [userId], references: [id], onDelete: SetNull)
  team             Team?              @relation(fields: [teamId], references: [id], onDelete: SetNull)
  memebers         Artist[]
}

model TeamProfile {
  id      String  @id @default(cuid())
  enabled Boolean @default(false)
  teamId  Int     @unique
  bio     String?

  team Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

enum UserSecurityAuditLogType {
  ACCOUNT_PROFILE_UPDATE
  ACCOUNT_SSO_LINK
  AUTH_2FA_DISABLE
  AUTH_2FA_ENABLE
  PASSKEY_CREATED
  PASSKEY_DELETED
  PASSKEY_UPDATED
  PASSWORD_RESET
  PASSWORD_UPDATE
  SIGN_OUT
  SIGN_IN
  SIGN_IN_FAIL
  SIGN_IN_2FA_FAIL
  SIGN_IN_PASSKEY_FAIL
}

model UserSecurityAuditLog {
  id        Int                      @id @default(autoincrement())
  userId    Int
  createdAt DateTime                 @default(now())
  type      UserSecurityAuditLogType
  userAgent String?
  ipAddress String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  createdAt DateTime @default(now())
  expiry    DateTime
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Passkey {
  id                   String    @id @default(cuid())
  userId               Int
  name                 String
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @default(now())
  lastUsedAt           DateTime?
  credentialId         Bytes
  credentialPublicKey  Bytes
  counter              BigInt
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String[]

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AnonymousVerificationToken {
  id        String   @id @unique @default(cuid())
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model VerificationToken {
  id          Int      @id @default(autoincrement())
  secondaryId String   @unique @default(cuid())
  identifier  String
  token       String   @unique
  completed   Boolean  @default(false)
  expires     DateTime
  createdAt   DateTime @default(now())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum WebhookTriggerEvents {
  DOCUMENT_CREATED
  DOCUMENT_SENT
  DOCUMENT_OPENED
  DOCUMENT_SIGNED
  DOCUMENT_COMPLETED
  DOCUMENT_REJECTED
  DOCUMENT_CANCELLED
}

model Webhook {
  id            String                 @id @default(cuid())
  webhookUrl    String
  eventTriggers WebhookTriggerEvents[]
  secret        String?
  enabled       Boolean                @default(true)
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @default(now()) @updatedAt
  userId        Int
  user          User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId        Int?
  team          Team?                  @relation(fields: [teamId], references: [id], onDelete: Cascade)
  webhookCalls  WebhookCall[]
}

enum WebhookCallStatus {
  SUCCESS
  FAILED
}

model WebhookCall {
  id              String               @id @default(cuid())
  status          WebhookCallStatus
  url             String
  event           WebhookTriggerEvents
  requestBody     Json
  responseCode    Int
  responseHeaders Json?
  responseBody    Json?
  createdAt       DateTime             @default(now())
  webhookId       String
  webhook         Webhook              @relation(fields: [webhookId], references: [id], onDelete: Cascade)
}

enum ApiTokenAlgorithm {
  SHA512
}

model ApiToken {
  id        Int               @id @default(autoincrement())
  name      String
  token     String            @unique
  algorithm ApiTokenAlgorithm @default(SHA512)
  expires   DateTime?
  createdAt DateTime          @default(now())
  userId    Int?
  user      User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId    Int?
  team      Team?             @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  INACTIVE
}

model Subscription {
  id                Int                @id @default(autoincrement())
  status            SubscriptionStatus @default(INACTIVE)
  planId            String             @unique
  priceId           String
  periodEnd         DateTime?
  userId            Int?
  teamId            Int?               @unique
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  cancelAtPeriodEnd Boolean            @default(false)

  team Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id                String  @id @default(cuid())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  // Some providers return created_at so we need to make it optional
  created_at        Int?
  // Stops next-auth from crashing when dealing with AzureAD
  ext_expires_in    Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  password          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String @id @default(cuid())
  sessionToken String @unique
  userId       Int

  ipAddress String?
  userAgent String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum DocumentStatus {
  DRAFT
  PENDING
  COMPLETED
  REJECTED
  ERROR
}

enum DocumentSource {
  DOCUMENT
  TEMPLATE
  TEMPLATE_DIRECT_LINK
  CHAT
}

enum DocumentVisibility {
  EVERYONE
  MANAGER_AND_ABOVE
  ADMIN
}

enum FolderType {
  DOCUMENT
  TEMPLATE
  CHAT
  CONTRACT
}

model Folder {
  id         String             @id @default(cuid())
  name       String
  userId     Int
  user       User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId     Int?
  team       Team?              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  pinned     Boolean            @default(false)
  parentId   String?
  parent     Folder?            @relation("FolderToFolder", fields: [parentId], references: [id], onDelete: Cascade)
  documents  Document[]
  templates  Template[]
  contracts  Contract[]
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @default(now()) @updatedAt
  subfolders Folder[]           @relation("FolderToFolder")
  visibility DocumentVisibility @default(EVERYONE)
  type       FolderType
  useToChat  Boolean            @default(false)

  @@index([userId])
  @@index([teamId])
  @@index([parentId])
  @@index([type])
}

/// @zod.import(["import { ZDocumentAuthOptionsSchema } from '@documenso/lib/types/document-auth';", "import { ZDocumentFormValuesSchema } from '@documenso/lib/types/document-form-values';"])
model Document {
  id             Int                 @id @default(autoincrement())
  qrToken        String? /// @zod.string.describe("The token for viewing the document using the QR code on the certificate.")
  externalId     String? /// @zod.string.describe("A custom external ID you can use to identify the document.")
  userId         Int /// @zod.number.describe("The ID of the user that created this document.")
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  authOptions    Json? /// [DocumentAuthOptions] @zod.custom.use(ZDocumentAuthOptionsSchema)
  formValues     Json? /// [DocumentFormValues] @zod.custom.use(ZDocumentFormValuesSchema)
  visibility     DocumentVisibility  @default(EVERYONE)
  title          String
  status         DocumentStatus      @default(DRAFT)
  recipients     Recipient[]
  fields         Field[]
  shareLinks     DocumentShareLink[]
  documentDataId String
  documentMeta   DocumentMeta?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @default(now()) @updatedAt
  completedAt    DateTime?
  deletedAt      DateTime?
  teamId         Int?
  templateId     Int?
  source         DocumentSource

  useLegacyFieldInsertion Boolean @default(false)

  useToChat             Boolean                @default(false)
  documentBodyExtracted DocumentBodyExtracted?
  documentData          DocumentData           @relation(fields: [documentDataId], references: [id], onDelete: Cascade)
  team                  Team?                  @relation(fields: [teamId], references: [id])
  template              Template?              @relation(fields: [templateId], references: [id], onDelete: SetNull)
  Chat                  Chat[]
  auditLogs             DocumentAuditLog[]
  folder                Folder?                @relation(fields: [folderId], references: [id], onDelete: Cascade)
  folderId              String?

  @@unique([documentDataId])
  @@index([userId])
  @@index([status])
  @@index([folderId])
}

model DocumentAuditLog {
  id         String   @id @default(cuid())
  documentId Int
  createdAt  DateTime @default(now())
  type       String
  data       Json

  // Details of the person who performed the action which caused the audit log.
  name      String?
  email     String?
  userId    Int?
  userAgent String?
  ipAddress String?

  Document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

enum DocumentDataType {
  S3_PATH
  BYTES
  BYTES_64
}

enum DocumentSigningOrder {
  PARALLEL
  SEQUENTIAL
}

model DocumentData {
  id          String           @id @default(cuid())
  type        DocumentDataType
  data        String
  initialData String
  document    Document?
  template    Template?
}

enum DocumentBodyExtractedStatus {
  ERROR
  PENDING
  COMPLETED
  PROCESSING
}

model DocumentBodyExtracted {
  id         String   @id @default(cuid())
  body       String
  status     String
  documentId Int      @unique
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

enum DocumentDistributionMethod {
  EMAIL
  NONE
}

/// @zod.import(["import { ZDocumentEmailSettingsSchema } from '@documenso/lib/types/document-email';"])
model DocumentMeta {
  id                     String               @id @default(cuid())
  subject                String?
  message                String?
  timezone               String?              @default("Etc/UTC") @db.Text
  password               String?
  dateFormat             String?              @default("yyyy-MM-dd hh:mm a") @db.Text
  documentId             Int                  @unique
  document               Document             @relation(fields: [documentId], references: [id], onDelete: Cascade)
  redirectUrl            String?
  signingOrder           DocumentSigningOrder @default(PARALLEL)
  allowDictateNextSigner Boolean              @default(false)

  typedSignatureEnabled  Boolean @default(true)
  uploadSignatureEnabled Boolean @default(true)
  drawSignatureEnabled   Boolean @default(true)

  language           String                     @default("en")
  distributionMethod DocumentDistributionMethod @default(EMAIL)
  emailSettings      Json? /// [DocumentEmailSettings] @zod.custom.use(ZDocumentEmailSettingsSchema)
}

enum ReadStatus {
  NOT_OPENED
  OPENED
}

enum SendStatus {
  NOT_SENT
  SENT
}

enum SigningStatus {
  NOT_SIGNED
  SIGNED
  REJECTED
}

enum RecipientRole {
  CC
  SIGNER
  VIEWER
  APPROVER
  ASSISTANT
}

/// @zod.import(["import { ZRecipientAuthOptionsSchema } from '@documenso/lib/types/document-auth';"])
model Recipient {
  id                Int           @id @default(autoincrement())
  documentId        Int?
  templateId        Int?
  email             String        @db.VarChar(255)
  name              String        @default("") @db.VarChar(255)
  token             String
  documentDeletedAt DateTime?
  expired           DateTime?
  signedAt          DateTime?
  authOptions       Json? /// [RecipientAuthOptions] @zod.custom.use(ZRecipientAuthOptionsSchema)
  signingOrder      Int? /// @zod.number.describe("The order in which the recipient should sign the document. Only works if the document is set to sequential signing.")
  rejectionReason   String?
  role              RecipientRole @default(SIGNER)
  readStatus        ReadStatus    @default(NOT_OPENED)
  signingStatus     SigningStatus @default(NOT_SIGNED)
  sendStatus        SendStatus    @default(NOT_SENT)
  document          Document?     @relation(fields: [documentId], references: [id], onDelete: Cascade)
  template          Template?     @relation(fields: [templateId], references: [id], onDelete: Cascade)
  fields            Field[]
  signatures        Signature[]

  @@unique([documentId, email])
  @@unique([templateId, email])
  @@index([documentId])
  @@index([templateId])
  @@index([token])
}

model Task {
  id          Int            @id @default(autoincrement())
  externalId  String? /// @zod.string.describe("A custom external ID you can use to identify the task.")
  userId      Int /// @zod.number.describe("The ID of the user that created this task.")
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  title       String
  description String?
  status      TaskStatus     @default(PENDING)
  priority    TaskPriority   @default(MEDIUM)
  dueDate     DateTime?
  assignees   TaskAssignee[]
  comments    TaskComment[]

  tags         String[]  @default([])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now()) @updatedAt
  completedAt  DateTime?
  deletedAt    DateTime?
  teamId       Int?
  projectId    Int?
  parentTaskId Int?

  team       Team?    @relation(fields: [teamId], references: [id])
  project    Project? @relation(fields: [projectId], references: [id])
  parentTask Task?    @relation("TaskHierarchy", fields: [parentTaskId], references: [id])
  subtasks   Task[]   @relation("TaskHierarchy")

  auditLogs TaskAuditLog[]

  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@index([teamId])
  @@index([projectId])
}

model TaskAssignee {
  id         Int      @id @default(autoincrement())
  taskId     Int
  userId     Int
  assignedAt DateTime @default(now())
  assignedBy Int /// User who assigned the task

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
}

model TaskComment {
  id        Int      @id @default(autoincrement())
  taskId    Int
  userId    Int
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
}

model TaskAttachment {
  id        Int      @id @default(autoincrement())
  taskId    Int? // Requerido
  userId    Int // Requerido
  name      String // Requerido
  createdAt DateTime @default(now()) // Automático
  user      User     @relation(fields: [userId], references: [id])
}

model TaskAuditLog {
  id        String   @id @default(cuid())
  taskId    Int
  createdAt DateTime @default(now())
  type      String
  data      Json

  name      String?
  email     String?
  userId    Int?
  userAgent String?
  ipAddress String?

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
  BLOCKED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum Release {
  Soft
  Focus
}

enum TypeOfRelease {
  Sencillo
  Album
  EP
}

// Modelo opcional para proyectos (si necesitas agrupar tareas)
model Project {
  id          Int           @id @default(autoincrement())
  name        String
  description String?
  startDate   DateTime?
  endDate     DateTime?
  status      ProjectStatus @default(ACTIVE)
  teamId      Int?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now()) @updatedAt

  team  Team?  @relation(fields: [teamId], references: [id])
  tasks Task[]
}

enum ProjectStatus {
  ACTIVE
  COMPLETED
  ARCHIVED
  ON_HOLD
}

enum FieldType {
  SIGNATURE
  FREE_SIGNATURE
  INITIALS
  NAME
  EMAIL
  DATE
  TEXT
  NUMBER
  RADIO
  CHECKBOX
  DROPDOWN
}

/// @zod.import(["import { ZFieldMetaNotOptionalSchema } from '@documenso/lib/types/field-meta';"])
model Field {
  id          Int        @id @default(autoincrement())
  secondaryId String     @unique @default(cuid())
  documentId  Int?
  templateId  Int?
  recipientId Int
  type        FieldType
  page        Int /// @zod.number.describe("The page number of the field on the document. Starts from 1.")
  positionX   Decimal    @default(0)
  positionY   Decimal    @default(0)
  width       Decimal    @default(-1)
  height      Decimal    @default(-1)
  customText  String
  inserted    Boolean
  document    Document?  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  template    Template?  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  recipient   Recipient  @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  signature   Signature?
  fieldMeta   Json? /// [FieldMeta] @zod.custom.use(ZFieldMetaNotOptionalSchema)

  @@index([documentId])
  @@index([templateId])
  @@index([recipientId])
}

model Signature {
  id                     Int      @id @default(autoincrement())
  created                DateTime @default(now())
  recipientId            Int
  fieldId                Int      @unique
  signatureImageAsBase64 String?
  typedSignature         String?

  recipient Recipient @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  field     Field     @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@index([recipientId])
}

model DocumentShareLink {
  id         Int      @id @default(autoincrement())
  email      String
  slug       String   @unique
  documentId Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, email])
}

enum TeamMemberRole {
  ADMIN
  MANAGER
  MEMBER
}

enum TeamMemberInviteStatus {
  ACCEPTED
  PENDING
  DECLINED
}

model TeamGlobalSettings {
  teamId                    Int                @unique
  documentVisibility        DocumentVisibility @default(EVERYONE)
  documentLanguage          String             @default("en")
  includeSenderDetails      Boolean            @default(true)
  includeSigningCertificate Boolean            @default(true)

  typedSignatureEnabled  Boolean @default(true)
  uploadSignatureEnabled Boolean @default(true)
  drawSignatureEnabled   Boolean @default(true)

  brandingEnabled        Boolean @default(false)
  brandingLogo           String  @default("")
  brandingUrl            String  @default("")
  brandingCompanyDetails String  @default("")
  brandingHidePoweredBy  Boolean @default(false)

  allowEmbeddedAuthoring Boolean @default(false)

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model Team {
  id                                  Int                                   @id @default(autoincrement())
  name                                String
  url                                 String                                @unique
  createdAt                           DateTime                              @default(now())
  avatarImageId                       String?
  customerId                          String?                               @unique
  ownerUserId                         Int
  Event                               Event[]
  members                             TeamMember[]
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]
  distributionStatementTerritories    DistributionStatementTerritories[]
  tuStreams                           tuStreams[]
  tuStreamsArtists                    tuStreamsArtists[]

  territories Territories[]
  isrcArtists IsrcArtists[]

  invites              TeamMemberInvite[]
  teamEmail            TeamEmail?
  emailVerification    TeamEmailVerification?
  transferVerification TeamTransferVerification?
  teamGlobalSettings   TeamGlobalSettings?
  avatarImage          AvatarImage?              @relation(fields: [avatarImageId], references: [id], onDelete: SetNull)
  songs                Songs[]
  musicPlatforms       MusicPlatforms[]

  isrcSongs                IsrcSongs[]
  artists                  Artist[]
  profile                  TeamProfile?
  owner                    User                       @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
  subscription             Subscription?
  distributionStatement    DistributionStatement[]
  releases                 Releases[]
  releasesArtists          releasesArtists[]
  contract                 Contract[]
  documents                Document[]
  tasks                    Task[]
  templates                Template[]
  projects                 Project[]
  folders                  Folder[]
  apiTokens                ApiToken[]
  webhooks                 Webhook[]
  Chat                     Chat[]
  contractTemplates        ContractTemplate[]
  lpm                      lpm[]
  lpmProductDisplayArtists lpmProductDisplayArtists[]
}

model TeamPending {
  id          Int      @id @default(autoincrement())
  name        String
  url         String   @unique
  createdAt   DateTime @default(now())
  customerId  String   @unique
  ownerUserId Int

  owner User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)
}

model TeamMember {
  id        Int            @id @default(autoincrement())
  teamId    Int
  createdAt DateTime       @default(now())
  role      TeamMemberRole
  userId    Int
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  team      Team           @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
}

model TeamEmail {
  teamId    Int      @id @unique
  createdAt DateTime @default(now())
  name      String
  email     String   @unique
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model TeamEmailVerification {
  teamId    Int      @id @unique
  name      String
  email     String
  token     String   @unique
  completed Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model TeamTransferVerification {
  teamId              Int      @id @unique
  userId              Int
  name                String
  email               String
  token               String   @unique
  completed           Boolean  @default(false)
  expiresAt           DateTime
  createdAt           DateTime @default(now())
  clearPaymentMethods Boolean  @default(false)

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model TeamMemberInvite {
  id        Int                    @id @default(autoincrement())
  teamId    Int
  createdAt DateTime               @default(now())
  email     String
  status    TeamMemberInviteStatus @default(PENDING)
  role      TeamMemberRole
  token     String                 @unique
  team      Team                   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, email])
}

enum TemplateType {
  PUBLIC
  PRIVATE
}

/// @zod.import(["import { ZDocumentEmailSettingsSchema } from '@documenso/lib/types/document-email';"])
model TemplateMeta {
  id                     String                     @id @default(cuid())
  subject                String?
  message                String?
  timezone               String?                    @default("Etc/UTC") @db.Text
  password               String?
  dateFormat             String?                    @default("yyyy-MM-dd hh:mm a") @db.Text
  signingOrder           DocumentSigningOrder?      @default(PARALLEL)
  allowDictateNextSigner Boolean                    @default(false)
  distributionMethod     DocumentDistributionMethod @default(EMAIL)

  typedSignatureEnabled  Boolean @default(true)
  uploadSignatureEnabled Boolean @default(true)
  drawSignatureEnabled   Boolean @default(true)

  templateId    Int      @unique
  template      Template @relation(fields: [templateId], references: [id], onDelete: Cascade)
  redirectUrl   String?
  language      String   @default("en")
  emailSettings Json? /// [DocumentEmailSettings] @zod.custom.use(ZDocumentEmailSettingsSchema)
}

/// @zod.import(["import { ZDocumentAuthOptionsSchema } from '@documenso/lib/types/document-auth';"])
model Template {
  id                     Int                @id @default(autoincrement())
  externalId             String?
  type                   TemplateType       @default(PRIVATE)
  title                  String
  userId                 Int
  teamId                 Int?
  visibility             DocumentVisibility @default(EVERYONE)
  authOptions            Json? /// [DocumentAuthOptions] @zod.custom.use(ZDocumentAuthOptionsSchema)
  templateMeta           TemplateMeta?
  templateDocumentDataId String
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @default(now()) @updatedAt
  publicTitle            String             @default("")
  publicDescription      String             @default("")

  useLegacyFieldInsertion Boolean @default(false)

  team                 Team?               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  templateDocumentData DocumentData        @relation(fields: [templateDocumentDataId], references: [id], onDelete: Cascade)
  user                 User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipients           Recipient[]
  fields               Field[]
  directLink           TemplateDirectLink?
  documents            Document[]
  folder               Folder?             @relation(fields: [folderId], references: [id], onDelete: Cascade)
  folderId             String?

  @@unique([templateDocumentDataId])
}

model TemplateDirectLink {
  id         String   @id @unique @default(cuid())
  templateId Int      @unique
  token      String   @unique
  createdAt  DateTime @default(now())
  enabled    Boolean

  directTemplateRecipientId Int

  template Template @relation(fields: [templateId], references: [id], onDelete: Cascade)
}

model SiteSettings {
  id                   String   @id
  enabled              Boolean  @default(false)
  data                 Json
  lastModifiedByUserId Int?
  lastModifiedAt       DateTime @default(now())
  lastModifiedByUser   User?    @relation(fields: [lastModifiedByUserId], references: [id], onDelete: SetNull)
}

enum BackgroundJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model BackgroundJob {
  id         String              @id @default(cuid())
  status     BackgroundJobStatus @default(PENDING)
  payload    Json?
  retried    Int                 @default(0)
  maxRetries Int                 @default(3)

  // Taken from the job definition
  jobId   String
  name    String
  version String

  submittedAt   DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  completedAt   DateTime?
  lastRetriedAt DateTime?

  tasks BackgroundJobTask[]
}

enum BackgroundJobTaskStatus {
  PENDING
  COMPLETED
  FAILED
}

model BackgroundJobTask {
  id     String                  @id
  name   String
  status BackgroundJobTaskStatus @default(PENDING)

  result     Json?
  retried    Int   @default(0)
  maxRetries Int   @default(3)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  jobId         String
  backgroundJob BackgroundJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
}

model AvatarImage {
  id    String @id @default(cuid())
  bytes String

  team Team[]
  user User[]
}

model ContractTemplate {
  id        Int       @id @default(autoincrement())
  name      String?   @db.VarChar(100)
  body      String?
  url       String?   @db.Text
  type      String?
  status    String?
  teamId    Int?
  team      Team?     @relation(fields: [teamId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deletedAt DateTime?

  @@map("ContractTemplates")
}

model Chat {
  id         String   @id @default(cuid())
  createdAt  DateTime
  title      String   @db.Text
  userId     Int
  documentId Int?
  teamId     Int?
  visibility String   @default("private") @db.VarChar(255)

  user       User                @relation(fields: [userId], references: [id])
  document   Document?           @relation(fields: [documentId], references: [id])
  team       Team?               @relation(fields: [teamId], references: [id])
  messagesV1 MessageDeprecated[]
  messagesV2 Message[]
  votesV1    VoteDeprecated[]
  votesV2    Vote[]

  @@map("Chat")
}

// DEPRECATED: Will be removed in the future
model MessageDeprecated {
  id        String   @id @default(cuid())
  chatId    String
  role      String   @db.VarChar(255)
  content   Json
  createdAt DateTime

  chat  Chat             @relation(fields: [chatId], references: [id])
  votes VoteDeprecated[]

  @@map("Message")
}

model Message {
  id          String   @id @default(cuid())
  chatId      String
  role        String   @db.VarChar(255)
  parts       Json
  attachments Json
  createdAt   DateTime

  chat  Chat   @relation(fields: [chatId], references: [id])
  votes Vote[]

  @@map("MessageV2")
}

// DEPRECATED: Will be removed in the future
model VoteDeprecated {
  chatId    String
  messageId String
  isUpvoted Boolean

  chat    Chat              @relation(fields: [chatId], references: [id])
  message MessageDeprecated @relation(fields: [messageId], references: [id])

  @@id([chatId, messageId])
  @@map("Vote")
}

model Vote {
  chatId    String
  messageId String
  isUpvoted Boolean

  chat    Chat    @relation(fields: [chatId], references: [id])
  message Message @relation(fields: [messageId], references: [id])

  @@id([chatId, messageId])
  @@map("Vote_v2")
}

model ChatDocument {
  id        String   @default(cuid())
  createdAt DateTime
  title     String   @db.Text
  content   String?  @db.Text
  kind      String   @default("text") @db.VarChar(255)
  userId    Int

  user        User         @relation(fields: [userId], references: [id])
  suggestions Suggestion[]

  @@id([id, createdAt])
  @@map("ChatDocument")
}

model Suggestion {
  id                String   @id @default(cuid())
  documentId        String
  documentCreatedAt DateTime
  originalText      String   @db.Text
  suggestedText     String   @db.Text
  description       String?  @db.Text
  isResolved        Boolean  @default(false)
  userId            Int
  createdAt         DateTime

  user     User         @relation(fields: [userId], references: [id])
  // Note: The foreign key relation is commented out in your Drizzle schema
  // You'll need to uncomment and fix this if needed
  document ChatDocument @relation(fields: [documentId, documentCreatedAt], references: [id, createdAt])

  @@map("Suggestion")
}

// Events table
model Event {
  id          Int       @id @default(autoincrement())
  name        String    @db.VarChar(300)
  description String?   @db.VarChar(200)
  image       String?   @db.Text
  teamId      Int?
  venue       String?   @db.VarChar(300)
  artists     Artist[]
  beginning   DateTime  @default(now())
  end         DateTime  @default(now())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  team         Team?         @relation(fields: [teamId], references: [id])
  ticketTypes  TicketType[]
  ticketBuyers TicketBuyer[]
}

// Buyers table
model Buyer {
  id               String    @id @default(cuid())
  password         String?
  uid              String?
  rfc              String?   @unique @db.VarChar(13)
  fullname         String    @db.VarChar(250)
  email            String    @unique @db.VarChar(250)
  image            String?   @db.Text
  emailVerified    DateTime?
  phoneNumber      String?   @db.VarChar(20)
  stripeCustomerId String    @unique @db.VarChar(255)
  createdAt        DateTime  @default(now())
  deletedAt        DateTime?

  ticketBuyers TicketBuyer[]
}

// Ticket types table
model TicketType {
  id                 Int       @id @default(autoincrement())
  name               String?   @db.VarChar(100)
  eventId            Int
  price              Int?
  uid                String?
  maxQuantityPerUser Int       @default(5)
  quantity           Int?
  available          Int?
  description        String?
  seatNumber         Int?
  stripeProductId    String?   @db.Text
  stripePriceId      String?   @db.Text
  imageUrl           String?   @db.Text
  status             String    @default("valid") @db.VarChar(20)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  deletedAt          DateTime?

  event Event @relation(fields: [eventId], references: [id])
}

// Tickets buyers table
model TicketBuyer {
  id              Int       @id @default(autoincrement())
  name            String?   @db.VarChar(100)
  eventId         Int
  buyerId         String
  ticketId        Int?
  price           Int?
  quantity        Int?
  stripeProductId String?   @db.Text
  imageUrl        String?   @db.Text
  status          String    @default("valid") @db.VarChar(20)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  event Event @relation(fields: [eventId], references: [id])
  buyer Buyer @relation(fields: [buyerId], references: [id])
}
